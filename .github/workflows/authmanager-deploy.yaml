# GitHub Actions CI/CD Pipeline for AuthorizationManager
# This workflow builds, tests, and deploys the AuthorizationManager service to Azure Kubernetes Service

name: AuthorizationManager CI/CD

on:
  push:
    branches:
      - main
    paths:
      - 'AuthorizationManager/**'
      - 'muzikaLib/**'  # Rebuild if shared library changes
      - '.github/workflows/authmanager-deploy.yaml'
      - 'k8s/authmanager/**'
  pull_request:
    branches:
      - main
    paths:
      - 'AuthorizationManager/**'
      - 'muzikaLib/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: 'Skip tests'
        required: false
        default: false
        type: boolean

env:
  JAVA_VERSION: '17'
  ACR_NAME: ${{ secrets.ACR_NAME }}
  AKS_CLUSTER_NAME: ${{ secrets.AKS_CLUSTER_NAME }}
  AKS_RESOURCE_GROUP: ${{ secrets.AKS_RESOURCE_GROUP }}
  IMAGE_NAME: muzika/authmanager

jobs:
  # Build and Test Job
  build:
    name: Build & Test
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      image_tag: ${{ steps.version.outputs.image_tag }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: maven

      - name: Cache Maven packages
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Generate version
        id: version
        run: |
          # Read version directly from pom.xml file (we're already in AuthorizationManager directory)
          # Extract the version from the project tag (second version tag in the file, after parent version)
          if [ -f "pom.xml" ]; then
            # Get all version tags and take the second one (project version, not parent version)
            VERSION=$(grep -o '<version>[^<]*</version>' pom.xml | sed 's/<version>\(.*\)<\/version>/\1/' | sed -n '2p' | tr -d '[:space:]')
          fi
          # Fallback to default if not found
          if [ -z "$VERSION" ] || [ "$VERSION" = "" ]; then
            VERSION="0.0.1-SNAPSHOT"
          fi
          SHORT_SHA=$(git rev-parse --short HEAD)
          IMAGE_TAG="${VERSION}-${SHORT_SHA}"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "Generated version: ${VERSION}, Image tag: ${IMAGE_TAG}"

      - name: Build AuthorizationManager
        run: |
          # Build from current directory (already in AuthorizationManager)
          mvn clean package -DskipTests -B

      - name: Run Tests
        if: ${{ github.event.inputs.skip_tests != 'true' }}
        run: |
          # Run tests from current directory (already in AuthorizationManager)
          mvn test -B
        continue-on-error: false

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: target/surefire-reports/
          retention-days: 7
          if-no-files-found: ignore

      - name: Upload JAR artifact
        uses: actions/upload-artifact@v4
        with:
          name: authmanager-jar
          path: target/*.jar
          retention-days: 1
          if-no-files-found: ignore

  # Docker Build and Push Job
  docker:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: maven

      - name: Login to Azure Container Registry
        uses: azure/docker-login@v1
        with:
          login-server: ${{ env.ACR_NAME }}.azurecr.io
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Build and Push Docker image with Jib
        env:
          ACR_NAME: ${{ env.ACR_NAME }}
        run: |
          # Build from current directory (already in AuthorizationManager)
          mvn compile jib:build \
            -Djib.to.image=${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image_tag }} \
            -Djib.to.tags=${{ needs.build.outputs.image_tag }},latest,${{ github.sha }} \
            -Djib.to.auth.username=${{ secrets.ACR_USERNAME }} \
            -Djib.to.auth.password=${{ secrets.ACR_PASSWORD }} \
            -B

      - name: Output image details
        run: |
          echo "### Docker Image Built" >> $GITHUB_STEP_SUMMARY
          echo "- **Registry:** ${{ env.ACR_NAME }}.azurecr.io" >> $GITHUB_STEP_SUMMARY
          echo "- **Image:** ${{ env.IMAGE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tag:** ${{ needs.build.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY

  # Deploy to AKS Job
  deploy:
    name: Deploy to AKS
    runs-on: ubuntu-latest
    needs: [build, docker]
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    environment: 
      name: ${{ github.event.inputs.environment || 'staging' }}
      url: https://${{ github.event.inputs.environment || 'staging' }}.muzika.example.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure Kubernetes context from secret
        id: kubeconfig-setup
        continue-on-error: true
        run: |
          if [ -n "${{ secrets.KUBE_CONFIG_BASE64 }}" ]; then
            echo "Using kubeconfig from secret"
            mkdir -p ${HOME}/.kube
            echo "${{ secrets.KUBE_CONFIG_BASE64 }}" | base64 --decode > ${HOME}/.kube/config
            chmod 600 ${HOME}/.kube/config
            kubectl config get-contexts
            echo "kubeconfig_used=true" >> $GITHUB_OUTPUT
          else
            echo "kubeconfig_used=false" >> $GITHUB_OUTPUT
          fi

      - name: Azure Login (fallback)
        if: steps.kubeconfig-setup.outputs.kubeconfig_used != 'true'
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS context (fallback)
        if: steps.kubeconfig-setup.outputs.kubeconfig_used != 'true'
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ env.AKS_RESOURCE_GROUP }}
          cluster-name: ${{ env.AKS_CLUSTER_NAME }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Create namespace if not exists
        run: |
          kubectl create namespace muzika --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy Kafka (first time setup)
        if: github.event.inputs.environment == 'staging' || github.event_name == 'push'
        run: |
          # Check if Kafka namespace exists
          if ! kubectl get namespace kafka &> /dev/null; then
            echo "Installing Strimzi Kafka Operator..."
            kubectl create namespace kafka
            kubectl apply -f 'https://strimzi.io/install/latest?namespace=kafka' -n kafka
            
            echo "Waiting for Strimzi operator to be ready..."
            kubectl wait --for=condition=Ready pod -l name=strimzi-cluster-operator -n kafka --timeout=300s
            
            echo "Deploying Kafka cluster..."
            # k8s files are at repo root, need to go up one level
            if [ -f "../k8s/kafka/kafka-cluster.yaml" ]; then
              kubectl apply -f ../k8s/kafka/kafka-cluster.yaml
            else
              echo "Warning: k8s/kafka/kafka-cluster.yaml not found"
            fi
            
            echo "Waiting for Kafka cluster to be ready..."
            kubectl wait kafka/kafka-cluster --for=condition=Ready --timeout=600s -n kafka || true
            
            echo "Creating Kafka topics..."
            if [ -f "../k8s/kafka/kafka-topics.yaml" ]; then
              kubectl apply -f ../k8s/kafka/kafka-topics.yaml
            else
              echo "Warning: k8s/kafka/kafka-topics.yaml not found"
            fi
          else
            echo "Kafka namespace exists, skipping Kafka setup"
          fi
        continue-on-error: true

      - name: Update image tag in deployment
        run: |
          # k8s files are at repo root, need to go up one level
          cd .. || true
          if [ -d "k8s/authmanager" ]; then
            cd k8s/authmanager
            # Update the image tag in kustomization.yaml
            sed -i "s/newTag: .*/newTag: ${{ needs.build.outputs.image_tag }}/" kustomization.yaml
            # Replace ACR_NAME placeholder
            sed -i "s/\${ACR_NAME}/${{ env.ACR_NAME }}/g" deployment.yaml
            sed -i "s/\${ACR_NAME}/${{ env.ACR_NAME }}/g" kustomization.yaml
          else
            echo "Warning: k8s/authmanager directory not found"
          fi

      - name: Deploy AuthorizationManager
        run: |
          echo "Applying Kubernetes manifests..."
          # k8s files are at repo root
          if [ -d "../k8s/authmanager" ]; then
            kubectl apply -k ../k8s/authmanager/
          else
            echo "Error: k8s/authmanager directory not found at repo root"
            exit 1
          fi
          
          echo "Waiting for deployment rollout..."
          kubectl rollout status deployment/authmanager -n muzika --timeout=300s

      - name: Verify deployment
        run: |
          echo "### Deployment Status" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n muzika -l app=authmanager >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          
          echo "Checking pod health..."
          kubectl get pods -n muzika -l app=authmanager -o wide
          
          echo "Recent pod events..."
          kubectl describe pods -n muzika -l app=authmanager | tail -20

      - name: Run smoke tests
        run: |
          echo "Running smoke tests..."
          # Get the service ClusterIP
          SERVICE_IP=$(kubectl get svc authmanager -n muzika -o jsonpath='{.spec.clusterIP}')
          
          # Create a test pod to run curl
          kubectl run smoke-test --image=curlimages/curl --rm -i --restart=Never -n muzika -- \
            curl -sf http://authmanager.muzika.svc.cluster.local:8091/actuator/health || \
            echo "Smoke test completed (may fail if service not yet ready)"
        continue-on-error: true

      - name: Cleanup on failure
        if: failure()
        run: |
          echo "Deployment failed. Checking logs..."
          kubectl logs -n muzika -l app=authmanager --tail=100 || true
          kubectl describe pods -n muzika -l app=authmanager || true

  # Notify Job
  notify:
    name: Notify
    runs-on: ubuntu-latest
    needs: [build, docker, deploy]
    if: always()
    
    steps:
      - name: Create deployment summary
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Build | ${{ needs.build.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Docker | ${{ needs.docker.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy | ${{ needs.deploy.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.build.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag:** ${{ needs.build.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY

